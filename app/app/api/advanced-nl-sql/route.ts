import { NextRequest, NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { geminiGenerate } from '@/lib/gemini'
import { isSafeSelectSQL, sanitizeLLMSQL } from '@/lib/sql-utils'

const prisma = new PrismaClient()
export const runtime = 'nodejs'

type ColumnMeta = {
  table_name: string
  column_name: string
  data_type: string
  is_nullable: string
}

type TableInfo = {
  table_name: string
  columns: Array<{
    name: string
    type: string
    nullable: boolean
  }>
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json()
    const question: string = body.question
    const execute: boolean = Boolean(body.execute)
    const limit: number = body.limit ?? 100

    if (!question?.trim()) {
      return NextResponse.json({ error: 'Missing question' }, { status: 400 })
    }

    // Fetch comprehensive schema with data types
    const schemaRows = (await prisma.$queryRaw`
      SELECT 
        table_name,
        column_name,
        data_type,
        is_nullable
      FROM information_schema.columns 
      WHERE table_schema = 'public'
      ORDER BY table_name, ordinal_position
    `) as ColumnMeta[]

    if (schemaRows.length === 0) {
      return NextResponse.json(
        { error: 'No tables found in public schema' },
        { status: 400 }
      )
    }

    // Group by table
    const tables: Record<string, TableInfo> = {}
    for (const row of schemaRows) {
      if (!tables[row.table_name]) {
        tables[row.table_name] = {
          table_name: row.table_name,
          columns: [],
        }
      }
      tables[row.table_name].columns.push({
        name: row.column_name,
        type: row.data_type,
        nullable: row.is_nullable === 'YES',
      })
    }

    const tableList = Object.values(tables)

    // Build Gemini prompt with schema context
    const schemaContext = tableList
      .map((t) => {
        const cols = t.columns
          .map((c) => `  - ${c.name} (${c.type}${c.nullable ? ', nullable' : ''})`)
          .join('\n')
        return `Table: ${t.table_name}\n${cols}`
      })
      .join('\n\n')

    const prompt = `You are an expert PostgreSQL query generator for employee analytics. Given the following database schema and a natural language question, generate a safe, optimized SQL SELECT query.

**Database Schema:**
${schemaContext}

**Rules:**
1. Generate ONLY a SELECT statement—no INSERT, UPDATE, DELETE, DROP, ALTER, etc.
2. Use double quotes for table/column names if they contain special characters or are case-sensitive.
3. Use parameterized queries with $1, $2, etc. for any filter values.
4. Include appropriate JOINs if multiple tables are needed.
5. Add GROUP BY, ORDER BY, and aggregations as appropriate.
6. Limit results to ${limit} rows unless the question asks for a specific count.
7. Return ONLY the SQL query—no explanations, no markdown code blocks, no extra text.
8. If the question is ambiguous, make reasonable assumptions based on common employee analytics patterns.
9. Prefer column aliases for clarity (e.g., AS avg_salary, AS department_name).
10. Use LOWER() for case-insensitive string comparisons when filtering.

**Question:** ${question}

**Generated SQL Query:**`

    let sql = ''
    let params: any[] = []
    let notes: string[] = []
    let chosenTable: string | undefined = undefined
    let usedGemini = false

    try {
      // Try Gemini first
      const geminiResponse = await geminiGenerate(prompt, {
        temperature: 0.1,
        maxOutputTokens: 1024,
      })

      const sanitized = sanitizeLLMSQL(geminiResponse)
      if (!sanitized) throw new Error('Failed to extract SQL from Gemini response')
      
      sql = sanitized
      usedGemini = true

      // Extract table name from SQL (simple heuristic)
      const fromMatch = sql.match(/FROM\s+"?(\w+)"?/i)
      if (fromMatch) chosenTable = fromMatch[1]

      // Extract parameters (basic heuristic: look for quoted strings in WHERE clauses)
      const whereMatch = sql.match(/WHERE\s+.*?'([^']+)'/gi)
      if (whereMatch) {
        whereMatch.forEach((m) => {
          const val = m.match(/'([^']+)'/)
          if (val) params.push(val[1])
        })
      }

      notes.push('Generated by Gemini Flash with schema awareness')
    } catch (geminiErr: any) {
      // Fallback to basic rule-based generator
      const { generateSql } = await import('@/lib/nl-sql')
      const schema: Record<string, any[]> = {}
      for (const row of schemaRows) {
        if (!schema[row.table_name]) schema[row.table_name] = []
        schema[row.table_name].push({
          table: row.table_name,
          column: row.column_name,
          dataType: row.data_type,
        })
      }

      const fallback = generateSql({ question, schema, limit })
      sql = fallback.sql
      params = fallback.params
      chosenTable = fallback.chosenTable
      notes = [
        ...(fallback.notes || []),
        `Gemini unavailable: ${geminiErr.message}`,
        'Fallback: rule-based generator',
      ]
    }

    // Safety check
    if (!isSafeSelectSQL(sql)) {
      return NextResponse.json(
        {
          sql,
          params,
          table: chosenTable,
          notes,
          error: 'Generated SQL contains unsafe operations and cannot be executed.',
        },
        { status: 400 }
      )
    }

    const response: any = {
      sql,
      params,
      table: chosenTable,
      notes,
      usedGemini,
    }

    // Execute if requested
    if (execute) {
      try {
        const results = await prisma.$queryRawUnsafe(sql, ...params)
        response.results = Array.isArray(results) ? results : []
      } catch (execErr: any) {
        response.execError = String(execErr.message || execErr)
        
        // Check for missing table
        if (execErr.code === '42P01') {
          response.execError = `Table not found. The generated query references a table that doesn't exist in your database. Please check your schema or try a different question.`
        }
      }
    }

    return NextResponse.json(response)
  } catch (err: any) {
    console.error('Advanced NL-SQL error:', err)
    return NextResponse.json(
      { error: 'Query generation failed', details: String(err.message || err) },
      { status: 500 }
    )
  }
}
